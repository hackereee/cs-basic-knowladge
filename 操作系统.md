# 内存模型

## 操作系统寻址方式
内存本身都指物理内存，但是物理内存不能同时满足操作系统不同程序的访问，为了满足不同的应用程序能够操作属于自己的物理地址，计算机设计了一种内存映射的机制，即分段和分页，这种机制本身由Cpu MMU（内存管理单元）提供，而操作系统通过这个机制实现了内存的管理。

## Linux 内存管理方式

前面提到了Cpu提供了MMU机制将虚拟地址映射为物理地址，具体其实现方式呢，是通过分段和分页两种机制来实现的，比如Intel X86 cpu就是通过分段和分页两个机制同时运用实现了虚拟地址和物理地址的管理，所以x86 Cpu 有段寄存器，而在Arm架构的Cpu上并没有段寄存器，也就是其只采用了页表的方式进行内存的划分，并没有使用段寄存器。这样能扁平化内存的使用，也降低了系统开发的内存管理复杂度。

而我们提到了X86 MMU使用了段 + 页的方式管理内存，实际上Linux或者现代的操作系统内核却巧妙的规避了段寄存器的存在，Linux通过将所有段的线性地址便宜都设置为0x0开始，寻址空间都设置为最大值（32位： $2^{32}$,4GB, 64位： $2^{64}$), 所以其线性地址就等于其逻辑地址， 线性地址 = 逻辑地址 + 线性地址偏移量，这样就巧妙的规避了内存分段的存在

所以只需要通过内存分页的方式来管理地址就好了，Cpu MMU将物理内存地址都建立两张表，一张页目录表，一张为页表，页目录表有一张，页表可以有很多很多张，每张页表1024个地址，具体取决于应用程序需要多少内存，然后动态的扩展和收缩，这个一步由操作系统实现，举个例子，一个应用程序进程创建后，Linux将页目录表的页表项都填为缺省的0，操作系统在访问内存的时候，Cpu 查询页目录所对应的页表项为0，Cpu就会触发一个缺页异常，Linux捕获这个异常，然后再去建立相应的页表以及页目录表与新页表的映射，整个过程对进程本身并不可见，进程只能访问到分配好后的地址，以正常的方式继续访问内存。

整个过程还是很复杂，这里只是一个简单的总结，具体可以参考以下的文章：

[如何理解虚拟地址空间？](https://www.zhihu.com/question/290504400?utm_id=0)

[Linux下逻辑地址-线性地址-物理地址详解](https://zhuanlan.zhihu.com/p/149674856)