binder已经是老生常谈的话题了，它是Android进程间的通信方式。
# 上层架构
首先binder是一个大的框架，上层通过代理端（proxy）和本地端（native）作为通信的数据传输的封装，proxy端为调用端，由它发起对native端的api调用，native端接收到调用信号之后，处理proxy端需要的数据，再回传给proxy端。
# 数据传输
前面说了binder数据传输的上层架构，那数据传输是如何实现的？这也是binder机制的核心-binder驱动，当两个进程需要通讯时，需要通过open打开binder驱动，然后通过
parcel进行数据的读取与传输。具体传输通过ioctl系统调用进行。

# 进程管理

## ServiceManager
上面说到了binder的上层设计以及binder数据传输，那还有一个重要的问题没有解决：那就是两个进程之间如何知道要读取或要发送的数据是对方的呢？这里就不得不提及Android进程管理中另外一个重要对象：ServiceManager.它管理了所有的Native端进程，每当一个新的进程需要提供数据时，其一般初始化为一个继承BnxxxServiceManager类, 其继承自BBinder,它是Native端的Binder对象，之后调用addService方法将其添加到ServiceManager里。
**PS**: 这里要说明一点：ServiceManager本身也是基于Binder机制实现的，它也分为Proxy与Native两个端
我们注册了Native端的Binder对象后，在Proxy调用BpServiceManager的getService函数获取该对象，该对象里有一个handle,可以理解为一个句柄，这个句柄用来指向对应的Binder对象，当获取到handle后，serviceManager会通过ProcessState的getStrongProxyForHandle函数将其转换为一个BpBinder对象。
至此我们已经知道了Native端被加入ServiceManager,而Proxy端则通过getService获取到了BpBinder对象，此时两个进程已经有了沟通的桥梁：Native端的BBinder对象和Proxy端的BpBinder

## 如何通信
Binder机制的通信就是通过轮询实现的，之前我们已经说了BBinder和BpBinder,  还有两个重要的对象ProcessState和IPCThreadState，我们在讲解整个流程之前还要再说明一个知识点，BBinder一般作为基础类出现，也就是BBinder会提供一个onTransact方法，用来处理Proxy发来的消息，该方法携带了命令以及调用所需数据，最终由真正实现的类去做接解析从而实现真正的方法调用；而BpBinder则是作为被包装对象出现，一般Proxy端会实现一个BpxxxService类，其内部包含所需进程的BpBinder, 这从getService获取BpBinder到变为BpxxxService这一步由BpInterface里定义的模板宏实现。
举个例子比较好理解：BpMediaPlayerService与BnMediaPlayerService, 结合上面的知识点，我们知道Bp就是Proxy端而Bn则是Native端，比如此时我们需要调用create方法，调用方（Proxy）调用create方法发起调用，我们根据之前描述，BpMediaPlayerService里有一个持有Native Binder对象hanlde的BpBinder,这个BpBinder会通过ProcessState调用transact方法将所需参数和需要调用的handle发送出去，具体就是将这些数据都包装到Parcel里，之后通过ioctl系统函数将这个parcel通过binder驱动传送到Native端；而在Native端呢，在其BnMediaPlayerService初始化的时候会打开binder驱动同事通过ProcessState调用IPCThreadState开启轮询读取binder驱动的数据，这一步同样使用ioctl调用来实现读取，当读取到新的消息和数据到来，IPCThreadState会将数据同样放到一个parcel中，前面我们已经提到过，在proxy调用transact函数时会发送当前Native端的handle，binder驱动会通过这个handle找到相应的BBinder,而这个BBinder就是我们的BnMediaPlayerSerivce的父类，最终IPCThreadState会调用BBinder的transact函数，BBinder会调用其内部的onTransact函数，我们之前说过BnMediaPlayerService会重写该函数，从而实现真正的调用，在这个例子当中，就是onTransact会解析相应命令，发现其对应到create方法，则最终就调用create方法，从而实现MediaPlayer的实例化，最终通过binder驱动将这个对象的相关信息返回回去（reply）。

至此我们完成了对Binder机制的大致梳理，但是其内部实现还是比较多代码，所以还要多多巩固。

参考文章：
[Android深入浅出之Binder机制](https://www.cnblogs.com/innost/archive/2011/01/09/1931456.html)
[Android Binder 机制详解](https://www.cnblogs.com/pwl999/p/15534947.html#46DeathRecipient_1656)